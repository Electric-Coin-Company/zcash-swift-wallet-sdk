// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: proto/proposal.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright (c) 2023 The Zcash developers
// Distributed under the MIT software license, see the accompanying
// file COPYING or https://www.opensource.org/licenses/mit-license.php .

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

enum FfiValuePool: SwiftProtobuf.Enum {
  typealias RawValue = Int

  /// Protobuf requires that enums have a zero discriminant as the default
  /// value. However, we need to require that a known value pool is selected,
  /// and we do not want to fall back to any default, so sending the
  /// PoolNotSpecified value will be treated as an error.
  case poolNotSpecified // = 0

  /// The transparent value pool (P2SH is not distinguished from P2PKH)
  case transparent // = 1

  /// The Sapling value pool
  case sapling // = 2

  /// The Orchard value pool
  case orchard // = 3
  case UNRECOGNIZED(Int)

  init() {
    self = .poolNotSpecified
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .poolNotSpecified
    case 1: self = .transparent
    case 2: self = .sapling
    case 3: self = .orchard
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .poolNotSpecified: return 0
    case .transparent: return 1
    case .sapling: return 2
    case .orchard: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension FfiValuePool: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [FfiValuePool] = [
    .poolNotSpecified,
    .transparent,
    .sapling,
    .orchard,
  ]
}

#endif  // swift(>=4.2)

/// The fee rule used in constructing a Proposal
enum FfiFeeRule: SwiftProtobuf.Enum {
  typealias RawValue = Int

  /// Protobuf requires that enums have a zero discriminant as the default
  /// value. However, we need to require that a known fee rule is selected,
  /// and we do not want to fall back to any default, so sending the
  /// FeeRuleNotSpecified value will be treated as an error.
  case notSpecified // = 0

  /// 10000 ZAT
  case preZip313 // = 1

  /// 1000 ZAT
  case zip313 // = 2

  /// MAX(10000, 5000 * logical_actions) ZAT
  case zip317 // = 3
  case UNRECOGNIZED(Int)

  init() {
    self = .notSpecified
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .notSpecified
    case 1: self = .preZip313
    case 2: self = .zip313
    case 3: self = .zip317
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .notSpecified: return 0
    case .preZip313: return 1
    case .zip313: return 2
    case .zip317: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension FfiFeeRule: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [FfiFeeRule] = [
    .notSpecified,
    .preZip313,
    .zip313,
    .zip317,
  ]
}

#endif  // swift(>=4.2)

/// A data structure that describes the inputs to be consumed and outputs to
/// be produced in a proposed transaction.
struct FfiProposal {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var protoVersion: UInt32 = 0

  /// ZIP 321 serialized transaction request
  var transactionRequest: String = String()

  /// The anchor height to be used in creating the transaction, if any.
  /// Setting the anchor height to zero will disallow the use of any shielded
  /// inputs.
  var anchorHeight: UInt32 = 0

  /// The inputs to be used in creating the transaction.
  var inputs: [FfiProposedInput] = []

  /// The total value, fee value, and change outputs of the proposed
  /// transaction
  var balance: FfiTransactionBalance {
    get {return _balance ?? FfiTransactionBalance()}
    set {_balance = newValue}
  }
  /// Returns true if `balance` has been explicitly set.
  var hasBalance: Bool {return self._balance != nil}
  /// Clears the value of `balance`. Subsequent reads from it will return its default value.
  mutating func clearBalance() {self._balance = nil}

  /// The fee rule used in constructing this proposal
  var feeRule: FfiFeeRule = .notSpecified

  /// The target height for which the proposal was constructed
  ///
  /// The chain must contain at least this many blocks in order for the proposal to
  /// be executed.
  var minTargetHeight: UInt32 = 0

  /// A flag indicating whether the proposal is for a shielding transaction,
  /// used for determining which OVK to select for wallet-internal outputs.
  var isShielding: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _balance: FfiTransactionBalance? = nil
}

/// The unique identifier and value for each proposed input.
struct FfiProposedInput {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var txid: Data = Data()

  var valuePool: FfiValuePool = .poolNotSpecified

  var index: UInt32 = 0

  var value: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// The proposed change outputs and fee value.
struct FfiTransactionBalance {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var proposedChange: [FfiChangeValue] = []

  var feeRequired: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// A proposed change output. If the transparent value pool is selected,
/// the `memo` field must be null.
struct FfiChangeValue {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var value: UInt64 = 0

  var valuePool: FfiValuePool = .poolNotSpecified

  var memo: FfiMemoBytes {
    get {return _memo ?? FfiMemoBytes()}
    set {_memo = newValue}
  }
  /// Returns true if `memo` has been explicitly set.
  var hasMemo: Bool {return self._memo != nil}
  /// Clears the value of `memo`. Subsequent reads from it will return its default value.
  mutating func clearMemo() {self._memo = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _memo: FfiMemoBytes? = nil
}

/// An object wrapper for memo bytes, to facilitate representing the
/// `change_memo == None` case.
struct FfiMemoBytes {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var value: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension FfiValuePool: @unchecked Sendable {}
extension FfiFeeRule: @unchecked Sendable {}
extension FfiProposal: @unchecked Sendable {}
extension FfiProposedInput: @unchecked Sendable {}
extension FfiTransactionBalance: @unchecked Sendable {}
extension FfiChangeValue: @unchecked Sendable {}
extension FfiMemoBytes: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "cash.z.wallet.sdk.ffi"

extension FfiValuePool: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "PoolNotSpecified"),
    1: .same(proto: "Transparent"),
    2: .same(proto: "Sapling"),
    3: .same(proto: "Orchard"),
  ]
}

extension FfiFeeRule: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "FeeRuleNotSpecified"),
    1: .same(proto: "PreZip313"),
    2: .same(proto: "Zip313"),
    3: .same(proto: "Zip317"),
  ]
}

extension FfiProposal: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Proposal"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "protoVersion"),
    2: .same(proto: "transactionRequest"),
    3: .same(proto: "anchorHeight"),
    4: .same(proto: "inputs"),
    5: .same(proto: "balance"),
    6: .same(proto: "feeRule"),
    7: .same(proto: "minTargetHeight"),
    8: .same(proto: "isShielding"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.protoVersion) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.transactionRequest) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.anchorHeight) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.inputs) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._balance) }()
      case 6: try { try decoder.decodeSingularEnumField(value: &self.feeRule) }()
      case 7: try { try decoder.decodeSingularUInt32Field(value: &self.minTargetHeight) }()
      case 8: try { try decoder.decodeSingularBoolField(value: &self.isShielding) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.protoVersion != 0 {
      try visitor.visitSingularUInt32Field(value: self.protoVersion, fieldNumber: 1)
    }
    if !self.transactionRequest.isEmpty {
      try visitor.visitSingularStringField(value: self.transactionRequest, fieldNumber: 2)
    }
    if self.anchorHeight != 0 {
      try visitor.visitSingularUInt32Field(value: self.anchorHeight, fieldNumber: 3)
    }
    if !self.inputs.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.inputs, fieldNumber: 4)
    }
    try { if let v = self._balance {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    if self.feeRule != .notSpecified {
      try visitor.visitSingularEnumField(value: self.feeRule, fieldNumber: 6)
    }
    if self.minTargetHeight != 0 {
      try visitor.visitSingularUInt32Field(value: self.minTargetHeight, fieldNumber: 7)
    }
    if self.isShielding != false {
      try visitor.visitSingularBoolField(value: self.isShielding, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: FfiProposal, rhs: FfiProposal) -> Bool {
    if lhs.protoVersion != rhs.protoVersion {return false}
    if lhs.transactionRequest != rhs.transactionRequest {return false}
    if lhs.anchorHeight != rhs.anchorHeight {return false}
    if lhs.inputs != rhs.inputs {return false}
    if lhs._balance != rhs._balance {return false}
    if lhs.feeRule != rhs.feeRule {return false}
    if lhs.minTargetHeight != rhs.minTargetHeight {return false}
    if lhs.isShielding != rhs.isShielding {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FfiProposedInput: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ProposedInput"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "txid"),
    2: .same(proto: "valuePool"),
    3: .same(proto: "index"),
    4: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.txid) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.valuePool) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.index) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self.value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.txid.isEmpty {
      try visitor.visitSingularBytesField(value: self.txid, fieldNumber: 1)
    }
    if self.valuePool != .poolNotSpecified {
      try visitor.visitSingularEnumField(value: self.valuePool, fieldNumber: 2)
    }
    if self.index != 0 {
      try visitor.visitSingularUInt32Field(value: self.index, fieldNumber: 3)
    }
    if self.value != 0 {
      try visitor.visitSingularUInt64Field(value: self.value, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: FfiProposedInput, rhs: FfiProposedInput) -> Bool {
    if lhs.txid != rhs.txid {return false}
    if lhs.valuePool != rhs.valuePool {return false}
    if lhs.index != rhs.index {return false}
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FfiTransactionBalance: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TransactionBalance"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "proposedChange"),
    2: .same(proto: "feeRequired"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.proposedChange) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.feeRequired) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.proposedChange.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.proposedChange, fieldNumber: 1)
    }
    if self.feeRequired != 0 {
      try visitor.visitSingularUInt64Field(value: self.feeRequired, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: FfiTransactionBalance, rhs: FfiTransactionBalance) -> Bool {
    if lhs.proposedChange != rhs.proposedChange {return false}
    if lhs.feeRequired != rhs.feeRequired {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FfiChangeValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ChangeValue"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
    2: .same(proto: "valuePool"),
    3: .same(proto: "memo"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.value) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.valuePool) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._memo) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.value != 0 {
      try visitor.visitSingularUInt64Field(value: self.value, fieldNumber: 1)
    }
    if self.valuePool != .poolNotSpecified {
      try visitor.visitSingularEnumField(value: self.valuePool, fieldNumber: 2)
    }
    try { if let v = self._memo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: FfiChangeValue, rhs: FfiChangeValue) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.valuePool != rhs.valuePool {return false}
    if lhs._memo != rhs._memo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FfiMemoBytes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MemoBytes"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.value.isEmpty {
      try visitor.visitSingularBytesField(value: self.value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: FfiMemoBytes, rhs: FfiMemoBytes) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
