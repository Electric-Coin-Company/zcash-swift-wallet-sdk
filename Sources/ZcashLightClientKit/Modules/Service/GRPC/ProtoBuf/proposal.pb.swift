// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: proto/proposal.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright (c) 2023 The Zcash developers
// Distributed under the MIT software license, see the accompanying
// file COPYING or https://www.opensource.org/licenses/mit-license.php .

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

enum FfiValuePool: SwiftProtobuf.Enum {
  typealias RawValue = Int

  /// Protobuf requires that enums have a zero discriminant as the default
  /// value. However, we need to require that a known value pool is selected,
  /// and we do not want to fall back to any default, so sending the
  /// PoolNotSpecified value will be treated as an error.
  case poolNotSpecified // = 0

  /// The transparent value pool (P2SH is not distinguished from P2PKH)
  case transparent // = 1

  /// The Sapling value pool
  case sapling // = 2

  /// The Orchard value pool
  case orchard // = 3
  case UNRECOGNIZED(Int)

  init() {
    self = .poolNotSpecified
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .poolNotSpecified
    case 1: self = .transparent
    case 2: self = .sapling
    case 3: self = .orchard
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .poolNotSpecified: return 0
    case .transparent: return 1
    case .sapling: return 2
    case .orchard: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension FfiValuePool: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [FfiValuePool] = [
    .poolNotSpecified,
    .transparent,
    .sapling,
    .orchard,
  ]
}

#endif  // swift(>=4.2)

/// The fee rule used in constructing a Proposal
enum FfiFeeRule: SwiftProtobuf.Enum {
  typealias RawValue = Int

  /// Protobuf requires that enums have a zero discriminant as the default
  /// value. However, we need to require that a known fee rule is selected,
  /// and we do not want to fall back to any default, so sending the
  /// FeeRuleNotSpecified value will be treated as an error.
  case notSpecified // = 0

  /// 10000 ZAT
  case preZip313 // = 1

  /// 1000 ZAT
  case zip313 // = 2

  /// MAX(10000, 5000 * logical_actions) ZAT
  case zip317 // = 3
  case UNRECOGNIZED(Int)

  init() {
    self = .notSpecified
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .notSpecified
    case 1: self = .preZip313
    case 2: self = .zip313
    case 3: self = .zip317
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .notSpecified: return 0
    case .preZip313: return 1
    case .zip313: return 2
    case .zip317: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension FfiFeeRule: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [FfiFeeRule] = [
    .notSpecified,
    .preZip313,
    .zip313,
    .zip317,
  ]
}

#endif  // swift(>=4.2)

/// A data structure that describes a series of transactions to be created.
struct FfiProposal {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The version of this serialization format.
  var protoVersion: UInt32 = 0

  /// The fee rule used in constructing this proposal
  var feeRule: FfiFeeRule = .notSpecified

  /// The target height for which the proposal was constructed
  ///
  /// The chain must contain at least this many blocks in order for the proposal to
  /// be executed.
  var minTargetHeight: UInt32 = 0

  /// The series of transactions to be created.
  var steps: [FfiProposalStep] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// A data structure that describes the inputs to be consumed and outputs to
/// be produced in a proposed transaction.
struct FfiProposalStep {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// ZIP 321 serialized transaction request
  var transactionRequest: String = String()

  /// The vector of selected payment index / output pool mappings. Payment index
  /// 0 corresponds to the payment with no explicit index.
  var paymentOutputPools: [FfiPaymentOutputPool] = []

  /// The anchor height to be used in creating the transaction, if any.
  /// Setting the anchor height to zero will disallow the use of any shielded
  /// inputs.
  var anchorHeight: UInt32 = 0

  /// The inputs to be used in creating the transaction.
  var inputs: [FfiProposedInput] = []

  /// The total value, fee value, and change outputs of the proposed
  /// transaction
  var balance: FfiTransactionBalance {
    get {return _balance ?? FfiTransactionBalance()}
    set {_balance = newValue}
  }
  /// Returns true if `balance` has been explicitly set.
  var hasBalance: Bool {return self._balance != nil}
  /// Clears the value of `balance`. Subsequent reads from it will return its default value.
  mutating func clearBalance() {self._balance = nil}

  /// A flag indicating whether the step is for a shielding transaction,
  /// used for determining which OVK to select for wallet-internal outputs.
  var isShielding: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _balance: FfiTransactionBalance? = nil
}

/// A mapping from ZIP 321 payment index to the output pool that has been chosen
/// for that payment, based upon the payment address and the selected inputs to
/// the transaction.
struct FfiPaymentOutputPool {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var paymentIndex: UInt32 = 0

  var valuePool: FfiValuePool = .poolNotSpecified

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// The unique identifier and value for each proposed input that does not
/// require a back-reference to a prior step of the proposal.
struct FfiReceivedOutput {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var txid: Data = Data()

  var valuePool: FfiValuePool = .poolNotSpecified

  var index: UInt32 = 0

  var value: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// A reference a payment in a prior step of the proposal. This payment must
/// belong to the wallet.
struct FfiPriorStepOutput {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var stepIndex: UInt32 = 0

  var paymentIndex: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// A reference a change output from a prior step of the proposal.
struct FfiPriorStepChange {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var stepIndex: UInt32 = 0

  var changeIndex: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// The unique identifier and value for an input to be used in the transaction.
struct FfiProposedInput {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var value: FfiProposedInput.OneOf_Value? = nil

  var receivedOutput: FfiReceivedOutput {
    get {
      if case .receivedOutput(let v)? = value {return v}
      return FfiReceivedOutput()
    }
    set {value = .receivedOutput(newValue)}
  }

  var priorStepOutput: FfiPriorStepOutput {
    get {
      if case .priorStepOutput(let v)? = value {return v}
      return FfiPriorStepOutput()
    }
    set {value = .priorStepOutput(newValue)}
  }

  var priorStepChange: FfiPriorStepChange {
    get {
      if case .priorStepChange(let v)? = value {return v}
      return FfiPriorStepChange()
    }
    set {value = .priorStepChange(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Value: Equatable {
    case receivedOutput(FfiReceivedOutput)
    case priorStepOutput(FfiPriorStepOutput)
    case priorStepChange(FfiPriorStepChange)

  #if !swift(>=4.1)
    static func ==(lhs: FfiProposedInput.OneOf_Value, rhs: FfiProposedInput.OneOf_Value) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.receivedOutput, .receivedOutput): return {
        guard case .receivedOutput(let l) = lhs, case .receivedOutput(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.priorStepOutput, .priorStepOutput): return {
        guard case .priorStepOutput(let l) = lhs, case .priorStepOutput(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.priorStepChange, .priorStepChange): return {
        guard case .priorStepChange(let l) = lhs, case .priorStepChange(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

/// The proposed change outputs and fee value.
struct FfiTransactionBalance {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A list of change output values.
  var proposedChange: [FfiChangeValue] = []

  /// The fee to be paid by the proposed transaction, in zatoshis.
  var feeRequired: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// A proposed change output. If the transparent value pool is selected,
/// the `memo` field must be null.
struct FfiChangeValue {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The value of a change output to be created, in zatoshis.
  var value: UInt64 = 0

  /// The value pool in which the change output should be created.
  var valuePool: FfiValuePool = .poolNotSpecified

  /// The optional memo that should be associated with the newly created change output.
  /// Memos must not be present for transparent change outputs.
  var memo: FfiMemoBytes {
    get {return _memo ?? FfiMemoBytes()}
    set {_memo = newValue}
  }
  /// Returns true if `memo` has been explicitly set.
  var hasMemo: Bool {return self._memo != nil}
  /// Clears the value of `memo`. Subsequent reads from it will return its default value.
  mutating func clearMemo() {self._memo = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _memo: FfiMemoBytes? = nil
}

/// An object wrapper for memo bytes, to facilitate representing the
/// `change_memo == None` case.
struct FfiMemoBytes {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var value: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension FfiValuePool: @unchecked Sendable {}
extension FfiFeeRule: @unchecked Sendable {}
extension FfiProposal: @unchecked Sendable {}
extension FfiProposalStep: @unchecked Sendable {}
extension FfiPaymentOutputPool: @unchecked Sendable {}
extension FfiReceivedOutput: @unchecked Sendable {}
extension FfiPriorStepOutput: @unchecked Sendable {}
extension FfiPriorStepChange: @unchecked Sendable {}
extension FfiProposedInput: @unchecked Sendable {}
extension FfiProposedInput.OneOf_Value: @unchecked Sendable {}
extension FfiTransactionBalance: @unchecked Sendable {}
extension FfiChangeValue: @unchecked Sendable {}
extension FfiMemoBytes: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "cash.z.wallet.sdk.ffi"

extension FfiValuePool: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "PoolNotSpecified"),
    1: .same(proto: "Transparent"),
    2: .same(proto: "Sapling"),
    3: .same(proto: "Orchard"),
  ]
}

extension FfiFeeRule: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "FeeRuleNotSpecified"),
    1: .same(proto: "PreZip313"),
    2: .same(proto: "Zip313"),
    3: .same(proto: "Zip317"),
  ]
}

extension FfiProposal: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Proposal"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "protoVersion"),
    2: .same(proto: "feeRule"),
    3: .same(proto: "minTargetHeight"),
    4: .same(proto: "steps"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.protoVersion) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.feeRule) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.minTargetHeight) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.steps) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.protoVersion != 0 {
      try visitor.visitSingularUInt32Field(value: self.protoVersion, fieldNumber: 1)
    }
    if self.feeRule != .notSpecified {
      try visitor.visitSingularEnumField(value: self.feeRule, fieldNumber: 2)
    }
    if self.minTargetHeight != 0 {
      try visitor.visitSingularUInt32Field(value: self.minTargetHeight, fieldNumber: 3)
    }
    if !self.steps.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.steps, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: FfiProposal, rhs: FfiProposal) -> Bool {
    if lhs.protoVersion != rhs.protoVersion {return false}
    if lhs.feeRule != rhs.feeRule {return false}
    if lhs.minTargetHeight != rhs.minTargetHeight {return false}
    if lhs.steps != rhs.steps {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FfiProposalStep: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ProposalStep"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "transactionRequest"),
    2: .same(proto: "paymentOutputPools"),
    3: .same(proto: "anchorHeight"),
    4: .same(proto: "inputs"),
    5: .same(proto: "balance"),
    6: .same(proto: "isShielding"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.transactionRequest) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.paymentOutputPools) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.anchorHeight) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.inputs) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._balance) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.isShielding) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.transactionRequest.isEmpty {
      try visitor.visitSingularStringField(value: self.transactionRequest, fieldNumber: 1)
    }
    if !self.paymentOutputPools.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.paymentOutputPools, fieldNumber: 2)
    }
    if self.anchorHeight != 0 {
      try visitor.visitSingularUInt32Field(value: self.anchorHeight, fieldNumber: 3)
    }
    if !self.inputs.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.inputs, fieldNumber: 4)
    }
    try { if let v = self._balance {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    if self.isShielding != false {
      try visitor.visitSingularBoolField(value: self.isShielding, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: FfiProposalStep, rhs: FfiProposalStep) -> Bool {
    if lhs.transactionRequest != rhs.transactionRequest {return false}
    if lhs.paymentOutputPools != rhs.paymentOutputPools {return false}
    if lhs.anchorHeight != rhs.anchorHeight {return false}
    if lhs.inputs != rhs.inputs {return false}
    if lhs._balance != rhs._balance {return false}
    if lhs.isShielding != rhs.isShielding {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FfiPaymentOutputPool: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PaymentOutputPool"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "paymentIndex"),
    2: .same(proto: "valuePool"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.paymentIndex) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.valuePool) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.paymentIndex != 0 {
      try visitor.visitSingularUInt32Field(value: self.paymentIndex, fieldNumber: 1)
    }
    if self.valuePool != .poolNotSpecified {
      try visitor.visitSingularEnumField(value: self.valuePool, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: FfiPaymentOutputPool, rhs: FfiPaymentOutputPool) -> Bool {
    if lhs.paymentIndex != rhs.paymentIndex {return false}
    if lhs.valuePool != rhs.valuePool {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FfiReceivedOutput: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ReceivedOutput"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "txid"),
    2: .same(proto: "valuePool"),
    3: .same(proto: "index"),
    4: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.txid) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.valuePool) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.index) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self.value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.txid.isEmpty {
      try visitor.visitSingularBytesField(value: self.txid, fieldNumber: 1)
    }
    if self.valuePool != .poolNotSpecified {
      try visitor.visitSingularEnumField(value: self.valuePool, fieldNumber: 2)
    }
    if self.index != 0 {
      try visitor.visitSingularUInt32Field(value: self.index, fieldNumber: 3)
    }
    if self.value != 0 {
      try visitor.visitSingularUInt64Field(value: self.value, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: FfiReceivedOutput, rhs: FfiReceivedOutput) -> Bool {
    if lhs.txid != rhs.txid {return false}
    if lhs.valuePool != rhs.valuePool {return false}
    if lhs.index != rhs.index {return false}
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FfiPriorStepOutput: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PriorStepOutput"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "stepIndex"),
    2: .same(proto: "paymentIndex"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.stepIndex) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.paymentIndex) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.stepIndex != 0 {
      try visitor.visitSingularUInt32Field(value: self.stepIndex, fieldNumber: 1)
    }
    if self.paymentIndex != 0 {
      try visitor.visitSingularUInt32Field(value: self.paymentIndex, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: FfiPriorStepOutput, rhs: FfiPriorStepOutput) -> Bool {
    if lhs.stepIndex != rhs.stepIndex {return false}
    if lhs.paymentIndex != rhs.paymentIndex {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FfiPriorStepChange: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PriorStepChange"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "stepIndex"),
    2: .same(proto: "changeIndex"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.stepIndex) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.changeIndex) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.stepIndex != 0 {
      try visitor.visitSingularUInt32Field(value: self.stepIndex, fieldNumber: 1)
    }
    if self.changeIndex != 0 {
      try visitor.visitSingularUInt32Field(value: self.changeIndex, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: FfiPriorStepChange, rhs: FfiPriorStepChange) -> Bool {
    if lhs.stepIndex != rhs.stepIndex {return false}
    if lhs.changeIndex != rhs.changeIndex {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FfiProposedInput: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ProposedInput"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "receivedOutput"),
    2: .same(proto: "priorStepOutput"),
    3: .same(proto: "priorStepChange"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: FfiReceivedOutput?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .receivedOutput(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .receivedOutput(v)
        }
      }()
      case 2: try {
        var v: FfiPriorStepOutput?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .priorStepOutput(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .priorStepOutput(v)
        }
      }()
      case 3: try {
        var v: FfiPriorStepChange?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .priorStepChange(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .priorStepChange(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.value {
    case .receivedOutput?: try {
      guard case .receivedOutput(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .priorStepOutput?: try {
      guard case .priorStepOutput(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .priorStepChange?: try {
      guard case .priorStepChange(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: FfiProposedInput, rhs: FfiProposedInput) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FfiTransactionBalance: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TransactionBalance"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "proposedChange"),
    2: .same(proto: "feeRequired"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.proposedChange) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.feeRequired) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.proposedChange.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.proposedChange, fieldNumber: 1)
    }
    if self.feeRequired != 0 {
      try visitor.visitSingularUInt64Field(value: self.feeRequired, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: FfiTransactionBalance, rhs: FfiTransactionBalance) -> Bool {
    if lhs.proposedChange != rhs.proposedChange {return false}
    if lhs.feeRequired != rhs.feeRequired {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FfiChangeValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ChangeValue"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
    2: .same(proto: "valuePool"),
    3: .same(proto: "memo"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.value) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.valuePool) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._memo) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.value != 0 {
      try visitor.visitSingularUInt64Field(value: self.value, fieldNumber: 1)
    }
    if self.valuePool != .poolNotSpecified {
      try visitor.visitSingularEnumField(value: self.valuePool, fieldNumber: 2)
    }
    try { if let v = self._memo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: FfiChangeValue, rhs: FfiChangeValue) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.valuePool != rhs.valuePool {return false}
    if lhs._memo != rhs._memo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FfiMemoBytes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MemoBytes"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.value.isEmpty {
      try visitor.visitSingularBytesField(value: self.value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: FfiMemoBytes, rhs: FfiMemoBytes) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
